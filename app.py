# -*- coding: utf-8 -*-
"""app (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZX0WE_5ocMUb1L4nPz2LnCun740zZfY2
"""

# -*- coding: utf-8 -*-
"""app (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ksumXY3oWvTbjXJ2KfbIYA1j9xnf55A8
"""

"""
AI-Powered Android Adware Detection System
Streamlit Web Application

Deploy to: Streamlit Cloud, Hugging Face Spaces, or Heroku
Author: Parisa hajibabaee
"""

import streamlit as st

# Page configuration - MUST BE FIRST STREAMLIT COMMAND
st.set_page_config(
    page_title="üõ°Ô∏è AI Adware Detector",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Now import other libraries
import pandas as pd
import numpy as np
import joblib
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
import time

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        padding: 1rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #667eea;
    }
    .success-box {
        background-color: #d4edda;
        color: #155724;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #28a745;
    }
    .danger-box {
        background-color: #f8d7da;
        color: #721c24;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #dc3545;
    }
    .info-box {
        background-color: #d1ecf1;
        color: #0c5460;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #17a2b8;
    }
</style>
""", unsafe_allow_html=True)


# Initialize session state
if 'analysis_history' not in st.session_state:
    st.session_state.analysis_history = []

@st.cache_resource
def load_models():
    """Load ML models and preprocessors (cached for performance)"""
    try:
        model = joblib.load('optimized_neural_network.pkl')
        scaler = joblib.load('scaler.pkl')
        features = joblib.load('feature_columns.pkl')

        # Load feature importance if available
        try:
            importance_df = pd.read_csv('feature_importance_rf.csv')
        except:
            importance_df = None

        return model, scaler, features, importance_df
    except Exception as e:
        st.error(f"‚ö†Ô∏è Error loading models: {str(e)}")
        st.stop()

def get_risk_level(adware_proba):
    """Determine risk level based on probability"""
    if adware_proba >= 0.7:
        return "üî¥ HIGH RISK", "#dc3545"
    elif adware_proba >= 0.3:
        return "üü° MEDIUM RISK", "#ffc107"
    else:
        return "üü¢ LOW RISK", "#28a745"

def generate_ai_explanation(app_data, prediction, confidence, adware_proba):
    """Generate AI-powered explanation"""

    explanation = "## ü§ñ AI Security Analysis\n\n"

    # 1. Threat Assessment
    explanation += "### 1Ô∏è‚É£ Threat Assessment\n\n"
    if prediction == 1:
        if adware_proba > 0.95:
            explanation += f"‚ö†Ô∏è **HIGH RISK**: This application exhibits strong adware characteristics with **{confidence:.1%} confidence**. "
            explanation += "The behavioral patterns closely match known adware samples in our dataset.\n\n"
        else:
            explanation += f"‚ö†Ô∏è **MODERATE RISK**: This application shows adware indicators with **{confidence:.1%} confidence**. "
            explanation += "Multiple suspicious patterns detected.\n\n"
    else:
        if adware_proba < 0.05:
            explanation += f"‚úÖ **LOW RISK**: Application appears benign with **{confidence:.1%} confidence**. "
            explanation += "Patterns align with legitimate applications.\n\n"
        else:
            explanation += f"‚úÖ **LOW-MODERATE RISK**: Likely benign with **{confidence:.1%} confidence**.\n\n"

    # 2. Behavioral Analysis
    explanation += "### 2Ô∏è‚É£ Behavioral Analysis\n\n"

    network_op = app_data.get('network_op', 0)
    http_clients = app_data.get('http_clients', 0)
    show_method = app_data.get('show_method', 0)

    if network_op > 10 and http_clients > 5:
        explanation += "- üî¥ **Excessive network communication** combined with multiple HTTP clients suggests "
        explanation += "potential ad fetching or data exfiltration behavior\n"

    if show_method > 50:
        explanation += "- üî¥ **Unusually high UI display activity** indicates aggressive ad display patterns\n"

    if prediction == 0:
        explanation += "- ‚úÖ Application behavior aligns with typical benign apps in dataset\n"
        explanation += "- ‚úÖ Resource usage within expected ranges\n"

    explanation += "\n"

    # 3. Technical Indicators
    explanation += "### 3Ô∏è‚É£ Technical Indicators\n\n"
    explanation += f"- **Network Operations**: {network_op:.0f} *(typical adware: ~45, benign: ~3)*\n"
    explanation += f"- **HTTP Clients**: {http_clients:.0f} *(typical adware: ~12, benign: ~2)*\n"
    explanation += f"- **UI Show Methods**: {show_method:.0f} *(typical adware: ~85, benign: ~25)*\n\n"

    # 4. Recommendation
    explanation += "### 4Ô∏è‚É£ Recommendation\n\n"

    if prediction == 1 and adware_proba > 0.95:
        explanation += "üö´ **BLOCK**: Immediate blocking recommended. High-confidence adware detection.\n"
    elif prediction == 1:
        explanation += "‚õî **QUARANTINE**: Isolate for further analysis before final decision.\n"
    elif adware_proba < 0.10:
        explanation += "‚úÖ **ALLOW**: Safe to proceed with normal usage.\n"
    else:
        explanation += "üëÅÔ∏è **MONITOR**: Likely safe but periodic checks recommended.\n"

    return explanation

def create_gauge_chart(value, title):
    """Create a gauge chart for metrics"""
    fig = go.Figure(go.Indicator(
        mode = "gauge+number+delta",
        value = value * 100,
        domain = {'x': [0, 1], 'y': [0, 1]},
        title = {'text': title, 'font': {'size': 20}},
        delta = {'reference': 95, 'increasing': {'color': "red"}},
        gauge = {
            'axis': {'range': [None, 100], 'tickwidth': 1},
            'bar': {'color': "darkblue"},
            'bgcolor': "white",
            'borderwidth': 2,
            'bordercolor': "gray",
            'steps': [
                {'range': [0, 50], 'color': '#28a745'},
                {'range': [50, 80], 'color': '#ffc107'},
                {'range': [80, 100], 'color': '#dc3545'}
            ],
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': 95
            }
        }
    ))

    fig.update_layout(height=250, margin=dict(l=20, r=20, t=50, b=20))
    return fig

def main():
    # Header
    st.markdown('<h1 class="main-header">üõ°Ô∏è AI-Powered Adware Detection System</h1>', unsafe_allow_html=True)

    st.markdown("""
    <div style='text-align: center; padding: 1rem; background-color: #f8f9fa; border-radius: 0.5rem; margin-bottom: 2rem;'>
        <p style='font-size: 1.2rem; margin: 0;'>
            üß† <strong>99.63% F1-Score</strong> Neural Network ‚Ä¢
            ü§ñ AI-Powered Explanations ‚Ä¢
            ‚ö° Real-time Detection
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Load models
    model, scaler, features, importance_df = load_models()

    # Sidebar
    with st.sidebar:
        st.image("https://img.icons8.com/clouds/200/shield.png", width=150)
        st.header("üéØ Analysis Options")

        analysis_mode = st.radio(
            "Choose Analysis Mode:",
            ["üì± Single App", "üìä Batch Processing", "üìà Feature Analysis", "‚ÑπÔ∏è About"]
        )

        st.markdown("---")

        # Model info
        st.subheader("üß† Model Information")
        st.metric("F1-Score", "99.63%", "Best")
        st.metric("Accuracy", "99.57%")
        st.metric("Features", len(features))

        st.markdown("---")

        st.markdown("""
        ### üöÄ Quick Tips
        - Upload CSV for instant analysis
        - AI explains every decision
        - Export results as PDF/CSV
        - Batch process unlimited apps
        """)

    # Main content based on selected mode
    if analysis_mode == "üì± Single App":
        show_single_app_analysis(model, scaler, features)

    elif analysis_mode == "üìä Batch Processing":
        show_batch_processing(model, scaler, features)

    elif analysis_mode == "üìà Feature Analysis":
        show_feature_analysis(importance_df)

    else:
        show_about_page()

def show_single_app_analysis(model, scaler, features):
    """Single app detection interface"""
    st.header("üì± Single App Detection")

    col1, col2 = st.columns([2, 1])

    with col1:
        st.subheader("Upload or Enter App Data")

        input_method = st.tabs(["üìÅ Upload CSV", "‚å®Ô∏è Manual Input", "üé≤ Use Sample"])

        with input_method[0]:
            st.info("üì§ Upload a CSV file with app features")
            uploaded_file = st.file_uploader("Choose CSV file", type=['csv'])

            if uploaded_file is not None:
                try:
                    df = pd.read_csv(uploaded_file)

                    if len(df) > 1:
                        st.warning(f"‚ö†Ô∏è File contains {len(df)} apps. Analyzing first app. Use 'Batch Processing' for multiple apps.")

                    app_data = df.iloc[0]
                    analyze_app(app_data, model, scaler, features)

                except Exception as e:
                    st.error(f"‚ùå Error reading file: {str(e)}")

        with input_method[1]:
            st.info("‚å®Ô∏è Enter feature values manually")

            # Create input fields for top features
            top_features = ['network_op', 'http_clients', 'show_method', 'sqllite_op',
                          'fileio_op', 'cyclomatic', 'methods', 'classes']

            col_a, col_b = st.columns(2)

            manual_data = {}
            for i, feature in enumerate(top_features):
                with col_a if i % 2 == 0 else col_b:
                    manual_data[feature] = st.number_input(
                        f"{feature}",
                        min_value=0.0,
                        value=0.0,
                        step=1.0,
                        key=f"manual_{feature}"
                    )

            if st.button("üîç Analyze App", type="primary"):
                # Create full feature dict
                full_data = {feat: 0.0 for feat in features}
                full_data.update(manual_data)

                analyze_app(pd.Series(full_data), model, scaler, features)

        with input_method[2]:
            st.info("üé≤ Use pre-loaded sample app for testing")

            col_sample1, col_sample2 = st.columns(2)

            with col_sample1:
                if st.button("üî¥ Test Adware Sample", type="primary"):
                    sample_adware = {feat: 0.0 for feat in features}
                    sample_adware.update({
                        'network_op': 45,
                        'http_clients': 12,
                        'show_method': 85,
                        'sqllite_op': 250,
                        'fileio_op': 180,
                    })
                    analyze_app(pd.Series(sample_adware), model, scaler, features)

            with col_sample2:
                if st.button("‚úÖ Test Benign Sample"):
                    sample_benign = {feat: 0.0 for feat in features}
                    sample_benign.update({
                        'network_op': 2,
                        'cyclomatic': 25000,
                        'methods': 40000,
                    })
                    analyze_app(pd.Series(sample_benign), model, scaler, features)

    with col2:
        st.subheader("üìä Analysis History")

        if st.session_state.analysis_history:
            for i, analysis in enumerate(reversed(st.session_state.analysis_history[-5:])):
                with st.expander(f"Analysis #{len(st.session_state.analysis_history)-i}"):
                    st.write(f"**Time:** {analysis['time']}")
                    st.write(f"**Result:** {analysis['result']}")
                    st.write(f"**Confidence:** {analysis['confidence']:.1%}")
        else:
            st.info("No analysis history yet")

def analyze_app(app_data, model, scaler, features):
    """Perform app analysis and display results"""

    with st.spinner("üîÑ Analyzing app..."):
        time.sleep(0.5)  # Visual feedback

        # Prepare features
        feature_values = []
        for feat in features:
            feature_values.append(app_data.get(feat, 0))

        X = np.array(feature_values).reshape(1, -1)
        X_scaled = scaler.transform(X)

        # Predict
        prediction = model.predict(X_scaled)[0]
        proba = model.predict_proba(X_scaled)[0]
        confidence = proba[prediction]
        adware_proba = proba[1]

        # Get risk level
        risk_level, risk_color = get_risk_level(adware_proba)

    # Display results
    st.success("‚úÖ Analysis Complete!")

    # Main result card
    result_label = "üî¥ ADWARE DETECTED" if prediction == 1 else "‚úÖ BENIGN"
    result_class = "danger-box" if prediction == 1 else "success-box"

    st.markdown(f"""
    <div class='{result_class}'>
        <h2 style='margin: 0;'>{result_label}</h2>
        <p style='font-size: 1.5rem; margin: 0.5rem 0;'>{risk_level}</p>
        <p style='margin: 0;'>Confidence: <strong>{confidence:.1%}</strong></p>
    </div>
    """, unsafe_allow_html=True)

    # Metrics
    st.subheader("üìä Detection Metrics")

    col1, col2, col3 = st.columns(3)

    with col1:
        st.plotly_chart(create_gauge_chart(confidence, "Confidence"), use_container_width=True)

    with col2:
        st.plotly_chart(create_gauge_chart(adware_proba, "Adware Probability"), use_container_width=True)

    with col3:
        # Key metrics
        st.metric("Network Operations", f"{app_data.get('network_op', 0):.0f}")
        st.metric("HTTP Clients", f"{app_data.get('http_clients', 0):.0f}")
        st.metric("UI Show Methods", f"{app_data.get('show_method', 0):.0f}")

    # Behavioral Analysis
    st.subheader("üîç Behavioral Analysis")

    network_op = app_data.get('network_op', 0)
    http_clients = app_data.get('http_clients', 0)
    show_method = app_data.get('show_method', 0)

    behaviors = []
    if network_op > 10:
        behaviors.append(("‚ö†Ô∏è High network activity", f"{network_op:.0f} operations", "warning"))
    if http_clients > 5:
        behaviors.append(("‚ö†Ô∏è Multiple HTTP clients", f"{http_clients:.0f} clients", "warning"))
    if show_method > 50:
        behaviors.append(("‚ö†Ô∏è Excessive UI displays", f"{show_method:.0f} show methods", "warning"))

    if behaviors:
        for label, value, type in behaviors:
            st.warning(f"{label}: **{value}**")
    else:
        st.success("‚úÖ No suspicious behaviors detected")

    # AI Explanation
    st.subheader("ü§ñ AI-Powered Explanation")

    explanation = generate_ai_explanation(app_data, prediction, confidence, adware_proba)
    st.markdown(explanation)

    # Export options
    col_exp1, col_exp2 = st.columns(2)

    with col_exp1:
        # Generate report text
        report = f"""
AI-POWERED ADWARE DETECTION REPORT
{'='*60}

Analysis Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Model: Neural Network (99.63% F1-Score)

DETECTION RESULTS
{'-'*60}
Classification: {result_label}
Confidence: {confidence:.2%}
Adware Probability: {adware_proba:.2%}
Risk Level: {risk_level}

BEHAVIORAL METRICS
{'-'*60}
Network Operations: {app_data.get('network_op', 0):.0f}
HTTP Clients: {app_data.get('http_clients', 0):.0f}
UI Show Methods: {app_data.get('show_method', 0):.0f}
Database Operations: {app_data.get('sqllite_op', 0):.0f}

{explanation}

{'='*60}
Powered by AI-Enhanced Detection System
        """

        st.download_button(
            "üìÑ Download Report (TXT)",
            report,
            file_name=f"adware_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
            mime="text/plain"
        )

    with col_exp2:
        # Create CSV export
        export_data = pd.DataFrame([{
            'timestamp': datetime.now(),
            'prediction': 'ADWARE' if prediction == 1 else 'BENIGN',
            'confidence': confidence,
            'adware_probability': adware_proba,
            'risk_level': risk_level,
            **{f: app_data.get(f, 0) for f in ['network_op', 'http_clients', 'show_method']}
        }])

        st.download_button(
            "üìä Download Data (CSV)",
            export_data.to_csv(index=False),
            file_name=f"detection_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv"
        )

    # Add to history
    st.session_state.analysis_history.append({
        'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'result': result_label,
        'confidence': confidence
    })

def show_batch_processing(model, scaler, features):
    """Batch processing interface"""
    st.header("üìä Batch Processing")

    st.info("üì§ Upload a CSV file with multiple apps to analyze them all at once")

    uploaded_file = st.file_uploader("Upload Batch CSV", type=['csv'], key="batch")

    if uploaded_file is not None:
        try:
            df = pd.read_csv(uploaded_file)

            st.success(f"‚úÖ Loaded {len(df)} apps")

            if st.button("üöÄ Process Batch", type="primary"):
                process_batch(df, model, scaler, features)

        except Exception as e:
            st.error(f"‚ùå Error: {str(e)}")

def process_batch(df, model, scaler, features):
    """Process batch of apps"""

    progress_bar = st.progress(0)
    status_text = st.empty()

    results = []

    for i, (idx, row) in enumerate(df.iterrows()):
        # Prepare features
        feature_values = [row.get(feat, 0) for feat in features]
        X = np.array(feature_values).reshape(1, -1)
        X_scaled = scaler.transform(X)

        # Predict
        prediction = model.predict(X_scaled)[0]
        proba = model.predict_proba(X_scaled)[0]

        results.append({
            'App #': i + 1,
            'App Name': row.get('file_name', f'App_{i+1}'),
            'Prediction': 'ADWARE' if prediction == 1 else 'BENIGN',
            'Confidence': f"{proba[prediction]:.2%}",
            'Risk Level': get_risk_level(proba[1])[0]
        })

        # Update progress
        progress_bar.progress((i + 1) / len(df))
        status_text.text(f"Processing... {i+1}/{len(df)}")

    status_text.text("‚úÖ Processing complete!")

    # Create results dataframe
    results_df = pd.DataFrame(results)

    # Display statistics
    st.subheader("üìà Batch Statistics")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("Total Apps", len(results_df))
    with col2:
        adware_count = len(results_df[results_df['Prediction'] == 'ADWARE'])
        st.metric("Adware Detected", adware_count, f"{adware_count/len(results_df)*100:.1f}%")
    with col3:
        benign_count = len(results_df[results_df['Prediction'] == 'BENIGN'])
        st.metric("Benign Apps", benign_count, f"{benign_count/len(results_df)*100:.1f}%")
    with col4:
        high_risk = len(results_df[results_df['Risk Level'] == 'üî¥ HIGH RISK'])
        st.metric("High Risk", high_risk)

    # Display results table
    st.subheader("üìã Detailed Results")
    st.dataframe(results_df, use_container_width=True)

    # Visualization
    st.subheader("üìä Visual Analysis")

    col_viz1, col_viz2 = st.columns(2)

    with col_viz1:
        # Pie chart
        prediction_counts = results_df['Prediction'].value_counts()
        fig_pie = px.pie(
            values=prediction_counts.values,
            names=prediction_counts.index,
            title="Prediction Distribution",
            color_discrete_sequence=['#28a745', '#dc3545']
        )
        st.plotly_chart(fig_pie, use_container_width=True)

    with col_viz2:
        # Risk level distribution
        risk_counts = results_df['Risk Level'].value_counts()
        fig_bar = px.bar(
            x=risk_counts.index,
            y=risk_counts.values,
            title="Risk Level Distribution",
            labels={'x': 'Risk Level', 'y': 'Count'},
            color=risk_counts.values,
            color_continuous_scale='RdYlGn_r'
        )
        st.plotly_chart(fig_bar, use_container_width=True)

    # Export
    st.subheader("üíæ Export Results")

    col_exp1, col_exp2 = st.columns(2)

    with col_exp1:
        st.download_button(
            "üìä Download Results (CSV)",
            results_df.to_csv(index=False),
            file_name=f"batch_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv"
        )

    with col_exp2:
        # Generate summary report
        summary = f"""
BATCH PROCESSING REPORT
{'='*60}

Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total Apps Analyzed: {len(results_df)}

SUMMARY
{'-'*60}
Adware Detected: {adware_count} ({adware_count/len(results_df)*100:.1%})
Benign Apps: {benign_count} ({benign_count/len(results_df)*100:.1%})
High Risk Apps: {high_risk}

DETAILED RESULTS
{'-'*60}
{results_df.to_string()}

{'='*60}
Generated by AI-Powered Adware Detection System
        """

        st.download_button(
            "üìÑ Download Report (TXT)",
            summary,
            file_name=f"batch_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
            mime="text/plain"
        )

def show_feature_analysis(importance_df):
    """Feature analysis and visualization"""
    st.header("üìà Feature Analysis")

    if importance_df is not None:
        st.subheader("üîù Top Important Features")

        # Display top features
        top_n = st.slider("Number of features to display", 5, 30, 15)
        top_features = importance_df.head(top_n)

        # Create interactive bar chart
        fig = px.bar(
            top_features,
            x='importance',
            y='feature',
            orientation='h',
            title=f'Top {top_n} Most Important Features',
            labels={'importance': 'Importance Score', 'feature': 'Feature'},
            color='importance',
            color_continuous_scale='Viridis'
        )
        fig.update_layout(height=max(400, top_n * 25))
        st.plotly_chart(fig, use_container_width=True)

        # Feature descriptions
        st.subheader("üìö Feature Descriptions")

        feature_descriptions = {
            'network_op': 'Number of network operations performed by the app',
            'http_clients': 'Number of HTTP client instances created',
            'show_method': 'Frequency of UI display method calls',
            'cyclomatic': 'Code complexity metric (McCabe complexity)',
            'methods': 'Total number of methods in the app',
            'classes': 'Total number of classes defined',
            'bytecode': 'Total bytecode instructions',
        }

        for i, row in top_features.head(10).iterrows():
            feature = row['feature']
            importance = row['importance']

            with st.expander(f"**{feature}** (Importance: {importance:.4f})"):
                desc = feature_descriptions.get(feature, "Static analysis metric from Android APK")
                st.write(desc)

                # Show typical values
                st.write("**Typical values:**")
                st.write("- Adware apps: Higher values indicate suspicious activity")
                st.write("- Benign apps: Lower, more consistent values")

    else:
        st.warning("‚ö†Ô∏è Feature importance data not available")

    # Model comparison
    st.subheader("üß† Model Performance Comparison")

    model_data = pd.DataFrame({
        'Model': ['Neural Network', 'Random Forest', 'Gradient Boosting'],
        'F1-Score': [0.9963, 0.9956, 0.9948],
        'Accuracy': [0.9957, 0.9948, 0.9943],
        'ROC-AUC': [0.9996, 0.9999, 0.9995]
    })

    metric_choice = st.selectbox("Select Metric", ['F1-Score', 'Accuracy', 'ROC-AUC'])

    fig_compare = px.bar(
        model_data,
        x='Model',
        y=metric_choice,
        title=f'Model Comparison - {metric_choice}',
        color=metric_choice,
        color_continuous_scale='Blues'
    )
    fig_compare.update_layout(showlegend=False, height=400)
    st.plotly_chart(fig_compare, use_container_width=True)

def show_about_page():
    """About page with system information"""
    st.header("‚ÑπÔ∏è About This System")

    col1, col2 = st.columns([2, 1])

    with col1:
        st.markdown("""
        ## üõ°Ô∏è AI-Powered Android Adware Detection

        This system uses advanced machine learning to detect adware in Android applications
        with **99.63% F1-Score accuracy**.

        ### üåü Key Features

        - **üß† Neural Network Model**: State-of-the-art deep learning
        - **ü§ñ AI Explanations**: Understand every decision
        - **‚ö° Real-time Detection**: Instant analysis
        - **üìä Batch Processing**: Analyze multiple apps
        - **üìà Feature Analysis**: Understand what matters
        - **üíæ Export Results**: Download reports

        ### üî¨ Technical Details

        - **Model**: Neural Network (100-50 hidden layers)
        - **Features**: 50 optimized static analysis features
        - **Training Data**: 24,192 apps (14,149 adware, 10,043 benign)
        - **Preprocessing**: StandardScaler + Yeo-Johnson transformation
        - **Validation**: 5-fold stratified cross-validation

        ### üìä Performance Metrics

        | Metric | Value |
        |--------|-------|
        | F1-Score | 99.63% |
        | Accuracy | 99.57% |
        | Precision | 99.69% |
        | Recall | 99.57% |
        | ROC-AUC | 99.96% |

        ### üéØ How It Works

        1. **Upload** an Android app's feature data (CSV format)
        2. **AI analyzes** 50+ behavioral and structural features
        3. **Get instant results** with confidence scores
        4. **Read AI explanation** understanding the decision
        5. **Export reports** for documentation

        ### üöÄ Use Cases

        - **App Store Security**: Scan apps before approval
        - **Enterprise Security**: Vet employee apps
        - **Research**: Malware pattern analysis
        - **Education**: Learn about ML in security
        - **Personal**: Check apps before installing
        """)

    with col2:
        st.info("""
        ### üìû Contact

        For questions or support:
        - GitHub: [Your Repo]
        - Email: your@email.com
        """)

        st.success("""
        ### üéì Citation

        If you use this system:

        ```
        AI-Powered Android Adware
        Detection System (2025)
        F1-Score: 99.63%
        ```
        """)

        st.warning("""
        ### ‚ö†Ô∏è Disclaimer

        This system is for
        educational and research
        purposes. Always verify
        results with additional
        security tools.
        """)

        st.markdown("""
        ### üìú License

        MIT License

        Open source and free
        to use!
        """)

# Run the app
if __name__ == "__main__":
    main()

